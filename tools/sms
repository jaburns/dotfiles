#!/usr/bin/env bash

# TODO check if monitor is running and don't run 2 instances
# TODO handle failure modes

usage () {
    echo 'Tool for managing SMS on connected Android device. Usage:'
    echo '  ./sms init'
    echo '  ./sms clean'
    echo '  ./sms grep $name'
    echo '  ./sms send ($id) $message'
    echo '  ./sms monitor'
}

query_sms () {
    adb shell su -c "sqlite3 /data/data/com.android.providers.telephony/databases/mmssms.db '$1'"
}

query_contacts () {
    adb shell su -c "sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db '$1'"
}

normalize_number () {
    local num="$(echo "$1" | sed 's/[^0-9]//g')"
    [[ ${#num} -lt 11 ]] && num="1$num"
    [[ ${#num} -lt 12 ]] && num="+$num"
    printf "$num"
}

lookup_contact () {
    local count=1
    grep -i "$1" /tmp/sms/contacts \
        | while read line; do
            local name="$(echo $line | cut -d\| -f1)"
            local num="$(echo $line | cut -d\| -f2)"
            echo " $count :: $num :: $name"
            echo "$num" > /tmp/sms/number-$count
            local count=$(expr $count + 1)
        done
}

get_name_from_number () {
    grep -i "$1" /tmp/sms/contacts | head -1 | cut -d\| -f1
}

send_message () {
    if [[ ! -e /tmp/sms/pin ]]; then
        echo 'Need to set phone pin'
        return 1;
    fi
    if [[ ! -z "$2" ]]; then
        local num=$(cat "/tmp/sms/number-$1")
        shift
    else
        local num=$(cat "/tmp/sms/number-1")
    fi
    echo "Sending message to $num..."
    adb shell input keyevent 26
    adb shell input text "$(cat /tmp/sms/pin)"
    adb shell input keyevent 66
    adb shell am start -a android.intent.action.SENDTO -d sms:$num --es sms_body "$1" --ez exit_on_sent true
    adb shell input keyevent 22
    adb shell input keyevent 66
    adb shell input keyevent 26
}

show_latest_sms () {
    query_sms "select * from (select address,body,type,date,_id from sms order by _id desc limit $1) order by _id asc" \
        | while read line; do
            local num="$(normalize_number "$(echo $line | cut -d\| -f1)")"
            local message="$(echo $line | cut -d\| -f2)"
            local mtype="$(echo $line | cut -d\| -f3)"
            local date="$(gdate -d @$(expr $(echo $line | cut -d\| -f4) / 1000) +'%a %l:%M %p')"
            local name="$(get_name_from_number $num)"
            case "$mtype" in
                1) local dash=': ' ;;
                2) local dash='<<' ;;
                *) local dash='--' ;;
            esac
            echo "$date ~ $name $dash $message"
        done
}

clean () {
    rm -rf /tmp/sms
}

init () {
    clean
    mkdir /tmp/sms
    read -p  "Enter phone PIN: " pin
    printf "$pin" > /tmp/sms/pin
    touch /tmp/sms/contacts
    printf "Generating normalized numbers for contacts list..."
    query_contacts 'select name,number from view_v1_phones' \
        | while read line; do
            local name="$(echo $line | cut -d\| -f1)"
            local num="$(normalize_number "$(echo $line | cut -d\| -f2 | sed 's/.$//')")"
            [[ ${#num} -eq 12 ]] && \
                echo "$name|$num" >> /tmp/sms/contacts
        done
    echo ' Done.'
}

monitor () {
    rm -f /tmp/sms/latest
    if [[ -z "$1" ]]; then
        local amount=20
    else
        local amount="$1"
    fi
    while true; do
        show_latest_sms "$amount" > /tmp/sms/latest
        clear
        cat /tmp/sms/latest
        sleep 5
    done
}

case "$1" in
    init) init ;;
    clean) clean ;;
    grep) lookup_contact "$2" ;;
    send) send_message "$2" "$3" ;;
    monitor) monitor "$2" ;;
    *) usage ;;
esac

